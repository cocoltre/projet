[Question Q1.1] L'algorithme de «clamping» de la position devra être appliqué dans
d'autres contextes que celui de la construction.
Comment le coder pour que sa réutilisation dans une autre méthode de
la classe Collider n'implique pas de duplication de code ?

[Reponse R1.1] Pour eviter la duplication de code on passe l'algorithme de clamping
par référence.

*******************************************************************************

[Question Q1.2] Comment utiliser des boucles pour éviter d'avoir un
code trop répétitif dans la mise en oeuvre de cet algorithme ?

[Reponse R1.2] On peut utiliser une boucle sur un array de positions possibles afin de trouver
la distance la plus courte entre deux points

*******************************************************************************

[Question Q1.3] Quels arguments de méthodes, parmi celles qu'il vous été demandé de coder
ci-dessus, vous semble-t-il judicieux de passer par référence constante ?

[Reponse R1.3] Les méthodes ayant des arguments pouvant être passées en références constantes
sont les méthodes directionTo, distanceTo et move car elles n'ont pas la vocation de changer
les valeurs de leurs arguments.

*******************************************************************************

[Question Q1.4] Quelles méthodes parmi celles que l'on vous a demandé de coder ci-dessus vous
semble-t-il judicieux de déclarer comme const ?

[Réponse R1.4]Les méthodes directionTo et distanceTo car elles ne modifient aucun attributs.

*******************************************************************************

[Question Q1.5] Comment coder les trois opérateurs précédemment décrits en évitant toute
duplication de code dans le fichier Collider.cpp ?

[Réponse R1.5] Il suffit de se servir des méthodes isColliderInside, isColliding, isPointInside
définies juste avant afin de coder les trois opérateurs.

*******************************************************************************

[Question Q1.6] Quelle surcharge choisissez-vous pour les opérateurs qu'il vous a été demandé
de coder (interne ou externe) et comment justifiez-vous ce choix ?

[Réponse R1.6] Il est utile de choisir une surcharge interne car les quatre opérateurs ont
besoin d'attributs de la classe pour fonctionner et donc cela permet de ne pas passer par
des getters.

*******************************************************************************

[Question Q1.7] Quels arguments de méthodes, parmi celles qu'il vous été demandé de coder
ci-dessus, vous semble-t-il judicieux de passer par référence constante ?

[Réponse R1.7] Toutes les méthodes ci-dessus n'ont pas besoin (et de doivent pas) modifier les
arguments qu'ils recoivent. On pourrait donc passer tous leurs arguments en référence constante.

*******************************************************************************

[Question Q1.8] Quelles méthodes parmi celles que l'on vous a demandé de coder ci-dessus vous
semble-t-il judicieux de déclarer comme const ?

[Réponse R1.8] Aucune des méthodes ne doivent modifier l'instance courante car elles ne font
que des testes et renvoient des bools.

*******************************************************************************

[Question Q2.1] Quelle taille donnez-vous à cells_?

[Réponse R2.1] cells_ prends la taille du carré de nbCells_.

*******************************************************************************

[Question Q2.2] À quelles séquences d'étiquettes du fichier .json correspondent les tournures
getAppConfig().world_cells et getAppConfig().world_size ?

[Réponse R2.2] getAppConfig().world_size correspond à la sequence d'étiquettes
["simulation"]["world"]["default size"]
               getAppConfig().world_cells ["simulation"]["world"]["default cells"]

*******************************************************************************

[Question Q2.3] Quelles méthodes seront invoquées pour réaliser ces initialisations et
dans quel ordre?

[Réponse R2.3] On utilise dans l'ordre reloadConfig, reloadCacheStructure et updateCache

*******************************************************************************

[Question Q2.4] Quel est l'avantage d'utiliser les méthodes ci-dessus plutôt que 
d'associer au flot de lecture, la chaîne de caractère "res/world.map" directement 
dans le code ?

[Réponse R2.4] 

*******************************************************************************

[Question Q2.5] Que doit faire la méthode loadFromFile pour mettre à jour les attributs
nécessaires au rendu graphique du terrain après l'initialisation de cells_ depuis un 
fichier ?

*******************************************************************************

[Question Q2.6] comment choisissez vous de représenter l'ensemble seeds_?

*******************************************************************************

[Question Q3.1] Pour le moment, dessiner un Env c'est simplement dessiner son terrain, 
lequel n'évolue pas une fois créé. Régénérer un Env c'est régénérer son terrain 
(au moyen de sa méthode reset). 
Comment proposez-vous de coder le corps des méthodes Env::drawOn, Env::update et 
Env::reset ?

[Réponse Q3.1] Ces méthodes devraient être codé en appelant les méthode de la classe 
World pour modifier le terrain (dessiner, updater et reseter).

*******************************************************************************

[Question Q3.2] Comment codez-vous cette méthode et où l'utiliserez vous dans le code 
écrit jusqu'ici pour la classe Env? 
Quel est le fichier qui sera utilisé concrètement pour initialiser le terrain? 
Enfin, quelle partie du code fourni fait en sorte que l'appui de la touche 'R' cause 
l'appel de la méthode reset de la classe Env?

[Réponse R3.2] loadWorldFromFile peut être codée en utilisant la méthode loadFromFile 
de la classe World, il est interessant d'ajouter un catch pour l'erreur renvoyé par 
loadFromFile. Le fichier pour initialiser le terrain sera """. 

*******************************************************************************

[Question Q3.3] À quel(s) endroit(s) du code existant de World, l'algorithme précédent 
doit-il être appliqué ? 
Comment sera t-il mis en oeuvre dans votre code (nouvelle(s) méthode(s))?

[Réponse R3.3] humidityRange doit être appliqué dans la fonction reloadConfig. """

*******************************************************************************

[Question Q3.4] La méthode updateCache parcourt déjà toutes les cellules (x,y) pour 
définir la transparence des sf::Quad des waterVertexes_, rockVertexes_ etc. 
Comment éviter un nouveau parcours de toutes les cellules (x,y) de humidityVertexes_?

[Réponse R3.4] On évite un nouveau parcours de toutes les cellules il faut traiter les 
humidityVertexes_ et les autresVertexes tous dans la même boucle.

*******************************************************************************

[Question Q3.5] Comment proposez-vous d'utiliser la classe Collider pour modéliser cet aspect ?

[Réponse R3.5] Flower est une sous classe de Collider, on peut donc utiliser les mêmes 
méthodes de Collider.

*******************************************************************************

[Question Q3.6] Si l'on tire au sort l'indice dans la méthode de dessin, la texture de la 
fleur va changer à chaque appel à la méthode de dessin. Comment faire pour assurer que le 
choix de la texture se fasse une fois pour toute lors de la création de la fleur?

